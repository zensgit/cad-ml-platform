"""
DXF Dataset Loader (2D).

Loads synthetic DXF data and labels for GNN training.
Converts raw entities (Lines, Circles) into a Graph structure.
"""

import json
import logging
import os
from typing import Any, Dict, List, Tuple

import ezdxf
import torch
from torch.utils.data import Dataset

logger = logging.getLogger(__name__)

# Feature dimensions (Contract)
# Node: [is_line, is_circle, length/radius, center_x, center_y, dir_x, dir_y] -> 7 dim
DXF_NODE_DIM = 7


class DXFDataset(Dataset):
    """
    PyTorch Dataset for 2D DXF Drawings.
    Reads labels.json generated by the synthetic generator.
    """

    def __init__(self, root_dir: str, transform=None):
        """
        Args:
            root_dir (str): Directory containing .dxf files and labels.json.
        """
        self.root_dir = root_dir
        self.transform = transform
        self.samples = []

        label_path = os.path.join(root_dir, "labels.json")
        if os.path.exists(label_path):
            with open(label_path, "r") as f:
                self.samples = json.load(f)
        else:
            logger.warning(f"Labels not found at {label_path}. Dataset empty.")

    def __len__(self):
        return len(self.samples)

    def __getitem__(self, idx):
        item = self.samples[idx]
        file_name = item["file"]
        file_path = os.path.join(self.root_dir, file_name)
        
        # Target: For this simple task, let's predict the number of holes (features count)
        # or classify if it has a specific feature.
        # Let's try: Count of Holes (Regression) or Has Slot (Classification)
        # Here: Classify "Has Slot" (0 or 1)
        features = item.get("features", [])
        has_slot = any(f["type"] == "slot" for f in features)
        label = torch.tensor([1.0 if has_slot else 0.0], dtype=torch.float)

        try:
            doc = ezdxf.readfile(file_path)
            msp = doc.modelspace()
            
            # Build Graph
            x, edge_index = self._dxf_to_graph(msp)
            
            return {
                "x": x, 
                "edge_index": edge_index,
                "file_name": file_name
            }, label.long().squeeze()

        except Exception as e:
            logger.error(f"Error parsing {file_name}: {e}")
            # Return empty graph on error
            return {
                "x": torch.zeros(0, DXF_NODE_DIM), 
                "edge_index": torch.zeros(2, 0, dtype=torch.long)
            }, label.long().squeeze()

    def _dxf_to_graph(self, msp) -> Tuple[torch.Tensor, torch.Tensor]:
        """Convert DXF entities to Node Features and Adjacency."""
        nodes = []
        # Naive approach: connect all entities to all (fully connected) for small graphs
        # Or connect entities that share endpoints (better).
        # For simplicity in this MVP: Fully connected graph of up to N entities.
        
        entities = list(msp)
        # Filter supported entities
        valid_entities = [e for e in entities if e.dxftype() in ["LINE", "CIRCLE", "LWPOLYLINE"]]
        
        # Limit graph size for stability
        max_nodes = 50
        valid_entities = valid_entities[:max_nodes]

        for e in valid_entities:
            feat = [0.0] * DXF_NODE_DIM
            dtype = e.dxftype()
            
            if dtype == "LINE":
                feat[0] = 1.0
                start = e.dxf.start
                end = e.dxf.end
                l = start.distance(end)
                feat[2] = l / 100.0  # Normalize
                # Center
                mid = (start + end) / 2
                feat[3] = mid.x / 200.0
                feat[4] = mid.y / 200.0
                # Direction
                d = (end - start).normalize()
                feat[5] = d.x
                feat[6] = d.y
                
            elif dtype == "CIRCLE":
                feat[1] = 1.0
                r = e.dxf.radius
                feat[2] = r / 50.0
                feat[3] = e.dxf.center.x / 200.0
                feat[4] = e.dxf.center.y / 200.0
                
            elif dtype == "LWPOLYLINE":
                # Treat polyline as a single complex node for now
                feat[0] = 0.5  # kind of a line?
                feat[1] = 0.5
                if len(e) > 0:
                    feat[3] = e[0][0] / 200.0
                    feat[4] = e[0][1] / 200.0

            nodes.append(feat)

        if not nodes:
            return torch.zeros(0, DXF_NODE_DIM), torch.zeros(2, 0, dtype=torch.long)

        x = torch.tensor(nodes, dtype=torch.float)
        
        # Fully connected edges (simplest for small graphs)
        num_nodes = len(nodes)
        if num_nodes > 1:
            row = torch.arange(num_nodes).repeat_interleave(num_nodes)
            col = torch.arange(num_nodes).repeat(num_nodes)
            # Remove self-loops from edge list? Optional.
            mask = row != col
            edge_index = torch.stack([row[mask], col[mask]], dim=0)
        else:
            edge_index = torch.zeros(2, 0, dtype=torch.long)

        return x, edge_index
