{
  "timestamp": "2025-12-29T01:28:05.760890+00:00",
  "summary": {
    "total_vulnerabilities": 74,
    "by_severity": {
      "critical": 0,
      "high": 43,
      "medium": 31,
      "low": 0
    },
    "by_type": {
      "python_dependency": 21,
      "code_security": 53
    }
  },
  "vulnerabilities": [
    {
      "type": "python_dependency",
      "package": "aiohttp",
      "installed_version": "3.9.0",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "aiohttp is an asynchronous HTTP client/server framework for asyncio and Python. When using aiohttp as a web server and configuring static routes, it is necessary to specify the root path for static files. Additionally, the option 'follow_symlinks' can be used to determine whether to follow symbolic links outside the static root directory. When 'follow_symlinks' is set to True, there is no validation to check if reading a file is within the root directory. This can lead to directory traversal vulnerabilities, resulting in unauthorized access to arbitrary files on the system, even when symlinks are not present.  Disabling follow_symlinks and using a reverse proxy are encouraged mitigations.  Version 3.9.2 fixes this issue.",
      "fix_version": "3.9.2",
      "cve": "PYSEC-2024-24"
    },
    {
      "type": "python_dependency",
      "package": "aiohttp",
      "installed_version": "3.9.0",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "aiohttp is an asynchronous HTTP client/server framework for asyncio and Python. Security-sensitive parts of the Python HTTP parser retained minor differences in allowable character sets, that must trigger error handling to robustly match frame boundaries of proxies in order to protect against injection of additional requests. Additionally, validation could trigger exceptions that were not handled consistently with processing of other malformed input.  Being more lenient than internet standards require could, depending on deployment environment, assist in request smuggling. The unhandled exception could cause excessive resource consumption on the application server and/or its logging facilities. This vulnerability exists due to an incomplete fix for CVE-2023-47627. Version 3.9.2 fixes this vulnerability.",
      "fix_version": "3.9.2",
      "cve": "PYSEC-2024-26"
    },
    {
      "type": "python_dependency",
      "package": "aiohttp",
      "installed_version": "3.9.0",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "### Summary  A XSS vulnerability exists on index pages for static file handling.  ### Details  When using `web.static(..., show_index=True)`, the resulting index pages do not escape file names.  If users can upload files with arbitrary filenames to the static directory, the server is vulnerable to XSS attacks.  ### Workaround  We have always recommended using a reverse proxy server (e.g. nginx) for serving static files. Users following the recommendation are unaffected.  Other users can disable `show_index` if unable to upgrade.  -----  Patch: https://github.com/aio-libs/aiohttp/pull/8319/files",
      "fix_version": "3.9.4",
      "cve": "CVE-2024-27306"
    },
    {
      "type": "python_dependency",
      "package": "aiohttp",
      "installed_version": "3.9.0",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "### Summary An attacker can send a specially crafted POST (multipart/form-data) request. When the aiohttp server processes it, the server will enter an infinite loop and be unable to process any further requests.  ### Impact An attacker can stop the application from serving requests after sending a single request.  -------  For anyone needing to patch older versions of aiohttp, the minimum diff needed to resolve the issue is (located in `_read_chunk_from_length()`):  ```diff diff --git a/aiohttp/multipart.py b/aiohttp/multipart.py index 227be605c..71fc2654a 100644 --- a/aiohttp/multipart.py +++ b/aiohttp/multipart.py @@ -338,6 +338,8 @@ class BodyPartReader:          assert self._length is not None, \"Content-Length required for chunked read\"          chunk_size = min(size, self._length - self._read_bytes)          chunk = await self._content.read(chunk_size) +        if self._content.at_eof(): +            self._at_eof = True          return chunk        async def _read_chunk_from_stream(self, size: int) -> bytes: ```  This does however introduce some very minor issues with handling form data. So, if possible, it would be recommended to also backport the changes in: https://github.com/aio-libs/aiohttp/commit/cebe526b9c34dc3a3da9140409db63014bc4cf19 https://github.com/aio-libs/aiohttp/commit/7eecdff163ccf029fbb1ddc9de4169d4aaeb6597 https://github.com/aio-libs/aiohttp/commit/f21c6f2ca512a026ce7f0f6c6311f62d6a638866",
      "fix_version": "3.9.4",
      "cve": "CVE-2024-30251"
    },
    {
      "type": "python_dependency",
      "package": "aiohttp",
      "installed_version": "3.9.0",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "### Summary The Python parser parses newlines in chunk extensions incorrectly which can lead to request smuggling vulnerabilities under certain conditions.  ### Impact If a pure Python version of aiohttp is installed (i.e. without the usual C extensions) or `AIOHTTP_NO_EXTENSIONS` is enabled, then an attacker may be able to execute a request smuggling attack to bypass certain firewalls or proxy protections.  -----  Patch: https://github.com/aio-libs/aiohttp/commit/259edc369075de63e6f3a4eaade058c62af0df71",
      "fix_version": "3.10.11",
      "cve": "CVE-2024-52304"
    },
    {
      "type": "python_dependency",
      "package": "aiohttp",
      "installed_version": "3.9.0",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "### Summary The Python parser is vulnerable to a request smuggling vulnerability due to not parsing trailer sections of an HTTP request.  ### Impact If a pure Python version of aiohttp is installed (i.e. without the usual C extensions) or AIOHTTP_NO_EXTENSIONS is enabled, then an attacker may be able to execute a request smuggling attack to bypass certain firewalls or proxy protections.  ----  Patch: https://github.com/aio-libs/aiohttp/commit/e8d774f635dc6d1cd3174d0e38891da5de0e2b6a",
      "fix_version": "3.12.14",
      "cve": "CVE-2025-53643"
    },
    {
      "type": "python_dependency",
      "package": "black",
      "installed_version": "23.11.0",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "Versions of the package black before 24.3.0 are vulnerable to Regular Expression Denial of Service (ReDoS) via the lines_with_leading_tabs_expanded function in the strings.py file. An attacker could exploit this vulnerability by crafting a malicious input that causes a denial of service.\r\rExploiting this vulnerability is possible when running Black on untrusted input, or if you habitually put thousands of leading tab characters in your docstrings.",
      "fix_version": "24.3.0",
      "cve": "PYSEC-2024-48"
    },
    {
      "type": "python_dependency",
      "package": "ecdsa",
      "installed_version": "0.19.1",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "python-ecdsa has been found to be subject to a Minerva timing attack on the P-256 curve. Using the `ecdsa.SigningKey.sign_digest()` API function and timing signatures an attacker can leak the internal nonce which may allow for private key discovery. Both ECDSA signatures, key generation, and ECDH operations are affected. ECDSA signature verification is unaffected. The python-ecdsa project considers side channel attacks out of scope for the project and there is no planned fix.",
      "fix_version": null,
      "cve": "CVE-2024-23342"
    },
    {
      "type": "python_dependency",
      "package": "fastapi",
      "installed_version": "0.104.1",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "FastAPI is a web framework for building APIs with Python 3.8+ based on standard Python type hints. When using form data, `python-multipart` uses a Regular Expression to parse the HTTP `Content-Type` header, including options. An attacker could send a custom-made `Content-Type` option that is very difficult for the RegEx to process, consuming CPU resources and stalling indefinitely (minutes or more) while holding the main event loop. This means that process can't handle any more requests. It's a ReDoS(Regular expression Denial of Service), it only applies to those reading form data, using `python-multipart`. This vulnerability has been patched in version 0.109.1.",
      "fix_version": "0.109.1",
      "cve": "PYSEC-2024-38"
    },
    {
      "type": "python_dependency",
      "package": "filelock",
      "installed_version": "3.20.0",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "### Impact  A Time-of-Check-Time-of-Use (TOCTOU) race condition allows local attackers to corrupt or truncate arbitrary user files through symlink attacks. The vulnerability exists in both Unix and Windows lock file creation where filelock checks if a file exists before opening it with O_TRUNC. An attacker can create a symlink pointing to a victim file in the time gap between the check and open, causing os.open() to follow the symlink and truncate the target file.  **Who is impacted:**  All users of filelock on Unix, Linux, macOS, and Windows systems. The vulnerability cascades to dependent libraries:  - **virtualenv users**: Configuration files can be overwritten with virtualenv metadata, leaking sensitive paths - **PyTorch users**: CPU ISA cache or model checkpoints can be corrupted, causing crashes or ML pipeline failures - **poetry/tox users**: through using virtualenv or filelock on their own.  Attack requires local filesystem access and ability to create symlinks (standard user permissions on Unix; Developer Mode on Windows 10+). Exploitation succeeds within 1-3 attempts when lock file paths are predictable.  ### Patches  Fixed in version **3.20.1**.  **Unix/Linux/macOS fix:** Added O_NOFOLLOW flag to os.open() in UnixFileLock.\\_acquire() to prevent symlink following.  **Windows fix:** Added GetFileAttributesW API check to detect reparse points (symlinks/junctions) before opening files in WindowsFileLock.\\_acquire().  **Users should upgrade to filelock 3.20.1 or later immediately.**  ### Workarounds  If immediate upgrade is not possible:  1. Use SoftFileLock instead of UnixFileLock/WindowsFileLock (note: different locking semantics, may not be suitable for all use cases) 2. Ensure lock file directories have restrictive permissions (chmod 0700) to prevent untrusted users from creating symlinks 3. Monitor lock file directories for suspicious symlinks before running trusted applications  **Warning:** These workarounds provide only partial mitigation. The race condition remains exploitable. Upgrading to version 3.20.1 is strongly recommended.  ______________________________________________________________________  ## Technical Details: How the Exploit Works  ### The Vulnerable Code Pattern  **Unix/Linux/macOS** (`src/filelock/_unix.py:39-44`):  ```python def _acquire(self) -> None:     ensure_directory_exists(self.lock_file)     open_flags = os.O_RDWR | os.O_TRUNC  # (1) Prepare to truncate     if not Path(self.lock_file).exists():  # (2) CHECK: Does file exist?         open_flags |= os.O_CREAT     fd = os.open(self.lock_file, open_flags, ...)  # (3) USE: Open and truncate ```  **Windows** (`src/filelock/_windows.py:19-28`):  ```python def _acquire(self) -> None:     raise_on_not_writable_file(self.lock_file)  # (1) Check writability     ensure_directory_exists(self.lock_file)     flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC  # (2) Prepare to truncate     fd = os.open(self.lock_file, flags, ...)  # (3) Open and truncate ```  ### The Race Window  The vulnerability exists in the gap between operations:  **Unix variant:**  ``` Time    Victim Thread                          Attacker Thread ----    -------------                          --------------- T0      Check: lock_file exists? \u2192 False T1                                             \u2193 RACE WINDOW T2                                             Create symlink: lock \u2192 victim_file T3      Open lock_file with O_TRUNC         \u2192 Follows symlink         \u2192 Opens victim_file         \u2192 Truncates victim_file to 0 bytes! \u2620\ufe0f ```  **Windows variant:**  ``` Time    Victim Thread                          Attacker Thread ----    -------------                          --------------- T0      Check: lock_file writable? T1                                             \u2193 RACE WINDOW T2                                             Create symlink: lock \u2192 victim_file T3      Open lock_file with O_TRUNC         \u2192 Follows symlink/junction         \u2192 Opens victim_file         \u2192 Truncates victim_file to 0 bytes! \u2620\ufe0f ```  ### Step-by-Step Attack Flow  **1. Attacker Setup:**  ```python # Attacker identifies target application using filelock lock_path = \"/tmp/myapp.lock\"  # Predictable lock path victim_file = \"/home/victim/.ssh/config\"  # High-value target ```  **2. Attacker Creates Race Condition:**  ```python import os import threading   def attacker_thread():     # Remove any existing lock file     try:         os.unlink(lock_path)     except FileNotFoundError:         pass      # Create symlink pointing to victim file     os.symlink(victim_file, lock_path)     print(f\"[Attacker] Created: {lock_path} \u2192 {victim_file}\")   # Launch attack threading.Thread(target=attacker_thread).start() ```  **3. Victim Application Runs:**  ```python from filelock import UnixFileLock  # Normal application code lock = UnixFileLock(\"/tmp/myapp.lock\") lock.acquire()  # \u2190 VULNERABILITY TRIGGERED HERE # At this point, /home/victim/.ssh/config is now 0 bytes! ```  **4. What Happens Inside os.open():**  On Unix systems, when `os.open()` is called:  ```c // Linux kernel behavior (simplified) int open(const char *pathname, int flags) {     struct file *f = path_lookup(pathname);  // Resolves symlinks by default!      if (flags & O_TRUNC) {         truncate_file(f);  // \u2190 Truncates the TARGET of the symlink     }      return file_descriptor; } ```  Without `O_NOFOLLOW` flag, the kernel follows the symlink and truncates the target file.  ### Why the Attack Succeeds Reliably  **Timing Characteristics:**  - **Check operation** (Path.exists()): ~100-500 nanoseconds - **Symlink creation** (os.symlink()): ~1-10 microseconds - **Race window**: ~1-5 microseconds (very small but exploitable) - **Thread scheduling quantum**: ~1-10 milliseconds  **Success factors:**  1. **Tight loop**: Running attack in a loop hits the race window within 1-3 attempts 2. **CPU scheduling**: Modern OS thread schedulers frequently context-switch during I/O operations 3. **No synchronization**: No atomic file creation prevents the race 4. **Symlink speed**: Creating symlinks is extremely fast (metadata-only operation)  ### Real-World Attack Scenarios  **Scenario 1: virtualenv Exploitation**  ```python # Victim runs: python -m venv /tmp/myenv # Attacker racing to create: os.symlink(\"/home/victim/.bashrc\", \"/tmp/myenv/pyvenv.cfg\")  # Result: /home/victim/.bashrc overwritten with: # home = /usr/bin/python3 # include-system-site-packages = false # version = 3.11.2 # \u2190 Original .bashrc contents LOST + virtualenv metadata LEAKED to attacker ```  **Scenario 2: PyTorch Cache Poisoning**  ```python # Victim runs: import torch # PyTorch checks CPU capabilities, uses filelock on cache # Attacker racing to create: os.symlink(\"/home/victim/.torch/compiled_model.pt\", \"/home/victim/.cache/torch/cpu_isa_check.lock\")  # Result: Trained ML model checkpoint truncated to 0 bytes # Impact: Weeks of training lost, ML pipeline DoS ```  ### Why Standard Defenses Don't Help  **File permissions don't prevent this:**  - Attacker doesn't need write access to victim_file - os.open() with O_TRUNC follows symlinks using the *victim's* permissions - The victim process truncates its own file  **Directory permissions help but aren't always feasible:**  - Lock files often created in shared /tmp directory (mode 1777) - Applications may not control lock file location - Many apps use predictable paths in user-writable directories  **File locking doesn't prevent this:**  - The truncation happens *during* the open() call, before any lock is acquired - fcntl.flock() only prevents concurrent lock acquisition, not symlink attacks  ### Exploitation Proof-of-Concept Results  From empirical testing with the provided PoCs:  **Simple Direct Attack** (`filelock_simple_poc.py`):  - Success rate: 33% per attempt (1 in 3 tries) - Average attempts to success: 2.1 - Target file reduced to 0 bytes in \\<100ms  **virtualenv Attack** (`weaponized_virtualenv.py`):  - Success rate: ~90% on first attempt (deterministic timing) - Information leaked: File paths, Python version, system configuration - Data corruption: Complete loss of original file contents  **PyTorch Attack** (`weaponized_pytorch.py`):  - Success rate: 25-40% per attempt - Impact: Application crashes, model loading failures - Recovery: Requires cache rebuild or model retraining  **Discovered and reported by:** George Tsigourakos (@tsigouris007)",
      "fix_version": "3.20.1",
      "cve": "CVE-2025-68146"
    },
    {
      "type": "python_dependency",
      "package": "h11",
      "installed_version": "0.14.0",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "### Impact  A leniency in h11's parsing of line terminators in chunked-coding message bodies can lead to request smuggling vulnerabilities under certain conditions.  ### Details  HTTP/1.1 Chunked-Encoding bodies are formatted as a sequence of \"chunks\", each of which consists of:  - chunk length - `\\r\\n` - `length` bytes of content - `\\r\\n`  In versions of h11 up to 0.14.0, h11 instead parsed them as:  - chunk length - `\\r\\n` - `length` bytes of content - any two bytes  i.e. it did not validate that the trailing `\\r\\n` bytes were correct, and if you put 2 bytes of garbage there it would be accepted, instead of correctly rejecting the body as malformed.  By itself this is harmless. However, suppose you have a proxy or reverse-proxy that tries to analyze HTTP requests, and your proxy has a _different_ bug in parsing Chunked-Encoding, acting as if the format is:  - chunk length - `\\r\\n` - `length` bytes of content - more bytes of content, as many as it takes until you find a `\\r\\n`  For example, [pound](https://github.com/graygnuorg/pound/pull/43) had this bug -- it can happen if an implementer uses a generic \"read until end of line\" helper to consumes the trailing `\\r\\n`.  In this case, h11 and your proxy may both accept the same stream of bytes, but interpret them differently. For example, consider the following HTTP request(s) (assume all line breaks are `\\r\\n`):  ``` GET /one HTTP/1.1 Host: localhost Transfer-Encoding: chunked  5 AAAAAXX2 45 0  GET /two HTTP/1.1 Host: localhost Transfer-Encoding: chunked  0 ```  Here h11 will interpret it as two requests, one with body `AAAAA45` and one with an empty body, while our hypothetical buggy proxy will interpret it as a single request, with body `AAAAXX20\\r\\n\\r\\nGET /two ...`. And any time two HTTP processors both accept the same string of bytes but interpret them differently, you have the conditions for a \"request smuggling\" attack. For example, if `/two` is a dangerous endpoint and the job of the reverse proxy is to stop requests from getting there, then an attacker could use a bytestream like the above to circumvent this protection.  Even worse, if our buggy reverse proxy receives two requests from different users:  ``` GET /one HTTP/1.1 Host: localhost Transfer-Encoding: chunked  5 AAAAAXX999 0 ```  ``` GET /two HTTP/1.1 Host: localhost Cookie: SESSION_KEY=abcdef... ```  ...it will consider the first request to be complete and valid, and send both on to the h11-based web server over the same socket. The server will then see the two concatenated requests, and interpret them as _one_ request to `/one` whose body includes `/two`'s session key, potentially allowing one user to steal another's credentials.  ### Patches  Fixed in h11 0.15.0.  ### Workarounds  Since exploitation requires the combination of buggy h11 with a buggy (reverse) proxy, fixing either component is sufficient to mitigate this issue.  ### Credits  Reported by Jeppe Bonde Weikop on 2025-01-09.",
      "fix_version": "0.16.0",
      "cve": "CVE-2025-43859"
    },
    {
      "type": "python_dependency",
      "package": "python-jose",
      "installed_version": "3.3.0",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "python-jose through 3.3.0 has algorithm confusion with OpenSSH ECDSA keys and other key formats. This is similar to CVE-2022-29217.",
      "fix_version": "3.4.0",
      "cve": "PYSEC-2024-232"
    },
    {
      "type": "python_dependency",
      "package": "python-jose",
      "installed_version": "3.3.0",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "python-jose through 3.3.0 allows attackers to cause a denial of service (resource consumption) during a decode via a crafted JSON Web Encryption (JWE) token with a high compression ratio, aka a \"JWT bomb.\" This is similar to CVE-2024-21319.",
      "fix_version": "3.4.0",
      "cve": "PYSEC-2024-233"
    },
    {
      "type": "python_dependency",
      "package": "python-multipart",
      "installed_version": "0.0.6",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "### Summary  When using form data, `python-multipart` uses a Regular Expression to parse the HTTP `Content-Type` header, including options.  An attacker could send a custom-made `Content-Type` option that is very difficult for the RegEx to process, consuming CPU resources and stalling indefinitely (minutes or more) while holding the main event loop. This means that process can't handle any more requests.  This can create a ReDoS (Regular expression Denial of Service): https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS  This only applies when the app uses form data, parsed with `python-multipart`.  ### Details  A regular HTTP `Content-Type` header could look like:  ``` Content-Type: text/html; charset=utf-8 ```  `python-multipart` parses the option with this RegEx: https://github.com/andrew-d/python-multipart/blob/d3d16dae4b061c34fe9d3c9081d9800c49fc1f7a/multipart/multipart.py#L72-L74  A custom option could be made and sent to the server to break it with:  ``` Content-Type: application/x-www-form-urlencoded; !=\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ ```  ### PoC  Create a simple WSGI application, that just parses the `Content-Type`, and run it with `python main.py`:  ```Python # main.py from wsgiref.simple_server import make_server from wsgiref.validate import validator  from multipart.multipart import parse_options_header   def simple_app(environ, start_response):     _, _ = parse_options_header(environ[\"CONTENT_TYPE\"])      start_response(\"200 OK\", [(\"Content-type\", \"text/plain\")])     return [b\"Ok\"]   httpd = make_server(\"\", 8123, validator(simple_app)) print(\"Serving on port 8123...\") httpd.serve_forever() ```  Then send the attacking request with:  ```console $ curl -v -X 'POST' -H $'Content-Type: application/x-www-form-urlencoded; !=\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' --data-binary 'input=1' 'http://localhost:8123/' ```  ### Impact  This is a ReDoS, (Regular expression Denial of Service), so it only applies to those using python-multipart to read form data, such as Starlette and FastAPI.  ### Original Report  This was originally reported to FastAPI as an email to security@tiangolo.com, sent via https://huntr.com/, the original reporter is Marcello, https://github.com/byt3bl33d3r  <details> <summary>Original report to FastAPI</summary>  Hey Tiangolo!  My name's Marcello and I work on the ProtectAI/Huntr Threat Research team, a few months ago we got a report (from @nicecatch2000) of a ReDoS affecting another very popular Python web framework. After some internal research, I found that FastAPI is vulnerable to the same ReDoS under certain conditions (only when it parses Form data not JSON).  Here are the details: I'm using the latest version of FastAPI (0.109.0) and the following code:  ```Python from typing import Annotated from fastapi.responses import HTMLResponse from fastapi import FastAPI,Form from pydantic import BaseModel  class Item(BaseModel):     username: str  app = FastAPI()  @app.get(\"/\", response_class=HTMLResponse) async def index():     return HTMLResponse(\"Test\", status_code=200)  @app.post(\"/submit/\") async def submit(username: Annotated[str, Form()]):     return {\"username\": username}  @app.post(\"/submit_json/\") async def submit_json(item: Item):     return {\"username\": item.username} ```  I'm running the above with uvicorn with the following command:  ```console uvicorn server:app ```  Then run the following cUrl command:  ``` curl -v -X 'POST' -H $'Content-Type: application/x-www-form-urlencoded; !=\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\' --data-binary 'input=1' 'http://localhost:8000/submit/' ```  You'll see the server locks up, is unable to serve anymore requests and one CPU core is pegged to 100%  You can even start uvicorn with multiple workers with the --workers 4 argument and as long as you send (workers + 1) requests you'll completely DoS the FastApi server.  If you try submitting Json to the /submit_json endpoint with the malicious Content-Type header you'll see it isn't vulnerable. So this only affects FastAPI when it parses Form data.  Cheers  #### Impact  An attacker is able to cause a DoS on a FastApi server via a malicious Content-Type header if it parses Form data.  #### Occurrences  [params.py L586](https://github.com/tiangolo/fastapi/blob/d74b3b25659b42233a669f032529880de8bd6c2d/fastapi/params.py#L586)  </details>",
      "fix_version": "0.0.7",
      "cve": "CVE-2024-24762"
    },
    {
      "type": "python_dependency",
      "package": "python-multipart",
      "installed_version": "0.0.6",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "### Summary  When parsing form data, `python-multipart` skips line breaks (CR `\\r` or LF `\\n`) in front of the first boundary and any tailing bytes after the last boundary. This happens one byte at a time and emits a log event each time, which may cause excessive logging for certain inputs.  An attacker could abuse this by sending a malicious request with lots of data before the first or after the last boundary, causing high CPU load and stalling the processing thread for a significant amount of time. In case of ASGI application, this could stall the event loop and prevent other requests from being processed, resulting in a denial of service (DoS).  ### Impact  Applications that use `python-multipart` to parse form data (or use frameworks that do so) are affected.   ### Original Report  This security issue was reported by: - GitHub security advisory in Starlette on October 30 by @Startr4ck - Email to `python-multipart` maintainer on October 3 by @mnqazi",
      "fix_version": "0.0.18",
      "cve": "CVE-2024-53981"
    },
    {
      "type": "python_dependency",
      "package": "requests",
      "installed_version": "2.31.0",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "When making requests through a Requests `Session`, if the first request is made with `verify=False` to disable cert verification, all subsequent requests to the same origin will continue to ignore cert verification regardless of changes to the value of `verify`. This behavior will continue for the lifecycle of the connection in the connection pool.  ### Remediation Any of these options can be used to remediate the current issue, we highly recommend upgrading as the preferred mitigation.  * Upgrade to `requests>=2.32.0`. * For `requests<2.32.0`, avoid setting `verify=False` for the first request to a host while using a Requests Session. * For `requests<2.32.0`, call `close()` on `Session` objects to clear existing connections if `verify=False` is used.  ### Related Links * https://github.com/psf/requests/pull/6655",
      "fix_version": "2.32.0",
      "cve": "CVE-2024-35195"
    },
    {
      "type": "python_dependency",
      "package": "requests",
      "installed_version": "2.31.0",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "### Impact  Due to a URL parsing issue, Requests releases prior to 2.32.4 may leak .netrc credentials to third parties for specific maliciously-crafted URLs.  ### Workarounds For older versions of Requests, use of the .netrc file can be disabled with `trust_env=False` on your Requests Session ([docs](https://requests.readthedocs.io/en/latest/api/#requests.Session.trust_env)).  ### References https://github.com/psf/requests/pull/6965 https://seclists.org/fulldisclosure/2025/Jun/2",
      "fix_version": "2.32.4",
      "cve": "CVE-2024-47081"
    },
    {
      "type": "python_dependency",
      "package": "scikit-learn",
      "installed_version": "1.3.2",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "A sensitive data leakage vulnerability was identified in scikit-learn's TfidfVectorizer, specifically in versions up to and including 1.4.1.post1, which was fixed in version 1.5.0. The vulnerability arises from the unexpected storage of all tokens present in the training data within the `stop_words_` attribute, rather than only storing the subset of tokens required for the TF-IDF technique to function. This behavior leads to the potential leakage of sensitive information, as the `stop_words_` attribute could contain tokens that were meant to be discarded and not stored, such as passwords or keys. The impact of this vulnerability varies based on the nature of the data being processed by the vectorizer.",
      "fix_version": "1.5.0",
      "cve": "PYSEC-2024-110"
    },
    {
      "type": "python_dependency",
      "package": "starlette",
      "installed_version": "0.27.0",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "### Summary Starlette treats `multipart/form-data` parts without a `filename` as text form fields and buffers those in byte strings with no size limit. This allows an attacker to upload arbitrary large form fields and cause Starlette to both slow down significantly due to excessive memory allocations and copy operations, and also consume more and more memory until the server starts swapping and grinds to a halt, or the OS terminates the server process with an OOM error. Uploading multiple such requests in parallel may be enough to render a service practically unusable, even if reasonable request size limits are enforced by a reverse proxy in front of Starlette.  ### PoC  ```python from starlette.applications import Starlette from starlette.routing import Route  async def poc(request):     async with request.form():         pass  app = Starlette(routes=[     Route('/', poc, methods=[\"POST\"]), ]) ```  ```sh curl http://localhost:8000 -F 'big=</dev/urandom' ```  ### Impact This Denial of service (DoS) vulnerability affects all applications built with Starlette (or FastAPI) accepting form requests. ",
      "fix_version": "0.40.0",
      "cve": "CVE-2024-47874"
    },
    {
      "type": "python_dependency",
      "package": "starlette",
      "installed_version": "0.27.0",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "### Summary When parsing a multi-part form with large files (greater than the [default max spool size](https://github.com/encode/starlette/blob/fa5355442753f794965ae1af0f87f9fec1b9a3de/starlette/formparsers.py#L126)) `starlette` will block the main thread to roll the file over to disk. This blocks the event thread which means we can't accept new connections.  ### Details Please see this discussion for details: https://github.com/encode/starlette/discussions/2927#discussioncomment-13721403. In summary the following UploadFile code (copied from [here](https://github.com/encode/starlette/blob/fa5355442753f794965ae1af0f87f9fec1b9a3de/starlette/datastructures.py#L436C5-L447C14)) has a minor bug. Instead of just checking for `self._in_memory` we should also check if the additional bytes will cause a rollover.  ```python      @property     def _in_memory(self) -> bool:         # check for SpooledTemporaryFile._rolled         rolled_to_disk = getattr(self.file, \"_rolled\", True)         return not rolled_to_disk      async def write(self, data: bytes) -> None:         if self.size is not None:             self.size += len(data)          if self._in_memory:             self.file.write(data)         else:             await run_in_threadpool(self.file.write, data) ```  I have already created a PR which fixes the problem: https://github.com/encode/starlette/pull/2962   ### PoC See the discussion [here](https://github.com/encode/starlette/discussions/2927#discussioncomment-13721403) for steps on how to reproduce.  ### Impact To be honest, very low and not many users will be impacted. Parsing large forms is already CPU intensive so the additional IO block doesn't slow down `starlette` that much on systems with modern HDDs/SSDs. If someone is running on tape they might see a greater impact.",
      "fix_version": "0.47.2",
      "cve": "CVE-2025-54121"
    },
    {
      "type": "python_dependency",
      "package": "tqdm",
      "installed_version": "4.66.1",
      "vulnerable_versions": "",
      "severity": "medium",
      "description": "### Impact Any optional non-boolean CLI arguments (e.g. `--delim`, `--buf-size`, `--manpath`) are passed through python's `eval`, allowing arbitrary code execution. Example:  ```sh python -m tqdm --manpath=\"\\\" + str(exec(\\\"import os\\nos.system('echo hi && killall python3')\\\")) + \\\"\" ```  ### Patches https://github.com/tqdm/tqdm/commit/4e613f84ed2ae029559f539464df83fa91feb316 released in `tqdm>=4.66.3`  ### Workarounds None  ### References - https://github.com/tqdm/tqdm/releases/tag/v4.66.3",
      "fix_version": "4.66.3",
      "cve": "CVE-2024-34062"
    },
    {
      "type": "code_security",
      "file": "src/core/active_learning.py",
      "line": 54,
      "severity": "medium",
      "confidence": "medium",
      "description": "Probable insecure usage of temp file/directory.",
      "cwe": {
        "id": 377,
        "link": "https://cwe.mitre.org/data/definitions/377.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/assembly/confidence_calibrator.py",
      "line": 399,
      "severity": "medium",
      "confidence": "high",
      "description": "Pickle and modules that wrap it can be unsafe when used to deserialize untrusted data, possible security issue.",
      "cwe": {
        "id": 502,
        "link": "https://cwe.mitre.org/data/definitions/502.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/config.py",
      "line": 13,
      "severity": "medium",
      "confidence": "medium",
      "description": "Possible binding to all interfaces.",
      "cwe": {
        "id": 605,
        "link": "https://cwe.mitre.org/data/definitions/605.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/dedupcad_precision/cad_pipeline.py",
      "line": 267,
      "severity": "high",
      "confidence": "high",
      "description": "subprocess call with shell=True identified, security issue.",
      "cwe": {
        "id": 78,
        "link": "https://cwe.mitre.org/data/definitions/78.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/ocr/providers/deepseek_hf.py",
      "line": 88,
      "severity": "medium",
      "confidence": "high",
      "description": "Unsafe Hugging Face Hub download without revision pinning in from_pretrained()",
      "cwe": {
        "id": 494,
        "link": "https://cwe.mitre.org/data/definitions/494.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/ocr/providers/deepseek_hf.py",
      "line": 89,
      "severity": "medium",
      "confidence": "high",
      "description": "Unsafe Hugging Face Hub download without revision pinning in from_pretrained()",
      "cwe": {
        "id": 494,
        "link": "https://cwe.mitre.org/data/definitions/494.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vectors/stores/faiss_store.py",
      "line": 94,
      "severity": "medium",
      "confidence": "high",
      "description": "Pickle and modules that wrap it can be unsafe when used to deserialize untrusted data, possible security issue.",
      "cwe": {
        "id": 502,
        "link": "https://cwe.mitre.org/data/definitions/502.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/ab_testing.py",
      "line": 350,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/access_control.py",
      "line": 535,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/alert_manager.py",
      "line": 610,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/api_gateway.py",
      "line": 126,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/apm_integration.py",
      "line": 467,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/audit_logger.py",
      "line": 297,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/automl_engine.py",
      "line": 640,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/automl_engine.py",
      "line": 717,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/compliance_checker.py",
      "line": 459,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/compliance_checker.py",
      "line": 473,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/compliance_checker.py",
      "line": 486,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/compliance_checker.py",
      "line": 566,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/deduplication.py",
      "line": 138,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/deduplication.py",
      "line": 140,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak SHA1 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/deployment.py",
      "line": 279,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/distributed_cache.py",
      "line": 313,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/distributed_cache.py",
      "line": 543,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/documentation_generator.py",
      "line": 231,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/embedding.py",
      "line": 168,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/encryption_manager.py",
      "line": 420,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/experiment_tracker.py",
      "line": 331,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/experiment_tracker.py",
      "line": 406,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/experiment_tracker.py",
      "line": 445,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/experiment_tracker.py",
      "line": 584,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/experiment_tracker.py",
      "line": 850,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/feature_flags.py",
      "line": 171,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/feature_flags.py",
      "line": 425,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/feature_store.py",
      "line": 510,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/graceful_degradation.py",
      "line": 272,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/intelligent_automation.py",
      "line": 1202,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/intelligent_routing.py",
      "line": 366,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/knowledge_base.py",
      "line": 648,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/log_aggregator.py",
      "line": 543,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/ml_integration.py",
      "line": 277,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/model_registry.py",
      "line": 664,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/observability.py",
      "line": 666,
      "severity": "medium",
      "confidence": "high",
      "description": "Use of possibly insecure function - consider using safer ast.literal_eval.",
      "cwe": {
        "id": 78,
        "link": "https://cwe.mitre.org/data/definitions/78.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/pipeline_orchestrator.py",
      "line": 502,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/recommendations.py",
      "line": 687,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/sdk_generator.py",
      "line": 205,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/security_scanner.py",
      "line": 279,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/security_scanner.py",
      "line": 354,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/security_scanner.py",
      "line": 435,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/service_mesh.py",
      "line": 486,
      "severity": "high",
      "confidence": "high",
      "description": "Use of weak MD5 hash for security. Consider usedforsecurity=False",
      "cwe": {
        "id": 327,
        "link": "https://cwe.mitre.org/data/definitions/327.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/core/vision/workflow_engine.py",
      "line": 734,
      "severity": "medium",
      "confidence": "high",
      "description": "Use of possibly insecure function - consider using safer ast.literal_eval.",
      "cwe": {
        "id": 78,
        "link": "https://cwe.mitre.org/data/definitions/78.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/ml/classifier.py",
      "line": 83,
      "severity": "medium",
      "confidence": "high",
      "description": "Pickle and modules that wrap it can be unsafe when used to deserialize untrusted data, possible security issue.",
      "cwe": {
        "id": 502,
        "link": "https://cwe.mitre.org/data/definitions/502.html"
      }
    },
    {
      "type": "code_security",
      "file": "src/ml/classifier.py",
      "line": 455,
      "severity": "medium",
      "confidence": "high",
      "description": "Pickle and modules that wrap it can be unsafe when used to deserialize untrusted data, possible security issue.",
      "cwe": {
        "id": 502,
        "link": "https://cwe.mitre.org/data/definitions/502.html"
      }
    }
  ],
  "recommendations": [
    "HIGH PRIORITY: Address high severity issues"
  ],
  "status": "fail"
}